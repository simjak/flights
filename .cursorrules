# Flight search service

Today is: 2024-12-23

Every time you choose to apply a rule(s), explicitly state the rule(s) in the output. You can abbreviate the rule description to a single word or phrase.

## Project Context
A Python-based Google Flights scraper that uses Protocol Buffers for data serialization.
The package provides a fast and strongly-typed way to access Google Flights data by:
- Generating Base64-encoded Protobuf strings for the tfs query parameter
- Parsing HTML content to extract flight information
- Providing strongly-typed interfaces for flight data handling

Key Features:
- Protocol Buffer-based data serialization
- Airport code enum support with autocompletion
- Support for multiple trip types (one-way, round-trip)
- Passenger configuration (adults, children, infants)
- Seat class selection (economy, premium-economy, business, first)
- Stop limit configuration
- Price trend indicators (low/typical/high)

## Architecture

The system consists of four main components:

1. **API Service**
   - FastAPI application handling HTTP requests
   - Job creation and status updates
   - Result retrieval and pagination
   - Database session management

2. **Worker Service**
   - Background job processing
   - Flight search implementation
   - State management and checkpointing
   - Rate limiting and error handling

3. **PostgreSQL Database**
   - Job and result storage
   - Status tracking
   - Data persistence
   - Concurrent access handling

4. **RabbitMQ Queue**
   - Job distribution
   - Worker coordination
   - Message persistence
   - Load balancing

### Data Flow
1. Client sends a flight search request to the API
2. API creates a job record in PostgreSQL
3. API enqueues the job in RabbitMQ
4. Worker dequeues and processes the job
5. Worker updates job status and stores results
6. Client retrieves results through the API

## Technical Requirements

### Backend Stack
- Python 3.12+
- FastAPI for REST API
- SQLAlchemy for database ORM
- PostgreSQL for data storage
- RabbitMQ for message queue
- UV for package management

### Code Style and Structure
- For backend, use Object-Oriented Programming patterns
- Prefer iteration and modularization over code duplication
- Use asyncio for asynchronous operations
- The asyncio.get_event_loop() method is deprecated in Python 3.10+ when called from within a coroutine
- Use Python 3.12 type hints:
  - Instead of Optional use e.g. str | None = None
  - Instead of Dict, List use list, dict
- Use deep methods and classes for complex logic instead of many small functions
- Use UV pyproject.yaml instead of pip and requirements.txt

### Database Schema
- Use enums for job_status ('pending', 'running', 'completed', 'failed', 'cancelled')
- Use enums for price_indicator ('low', 'typical', 'high')
- Implement proper indexes for performance
- Use UUID for primary keys
- Implement cascading deletes for related records
- Use timestamp tracking for all records

### Error Handling
- Implement proper error boundaries
- Log errors appropriately for debugging
- Provide user-friendly error messages
- Handle network failures gracefully
- Implement retry mechanisms with backoff
- Use circuit breakers for external services
- Log full stack traces in development

### Performance Rules
- Use connection pooling for database
- Implement proper database indexing
- Use async/await for I/O operations
- Implement rate limiting for external APIs
- Use caching where appropriate
- Implement pagination for large result sets
- Monitor memory usage in worker processes
- Use batch processing for bulk operations

### Testing
- Write unit tests for utilities and components
- Implement E2E tests for critical flows
- Test memory usage and performance
- Test error handling and recovery
- Test concurrent access patterns
- Test data consistency
- Implement performance benchmarks

### Security
- Implement Content Security Policy
- Sanitize user inputs
- Handle sensitive data properly
- Implement proper CORS handling
- Use secure database connections
- Implement rate limiting
- Validate all user inputs
- Use proper error messages (no leaks)

### Monitoring
- Implement health checks
- Track performance metrics
- Monitor queue sizes
- Track error rates
- Monitor resource usage
- Set up alerting
- Track job progress

### Documentation Rules
- Maintain clear README with setup instructions
- Document API interactions and data flows
- Keep manifest.json well-documented
- Don't include comments unless it's for complex logic
- Document permission requirements
- Include architecture diagrams
- Document error codes and handling
- Maintain changelog

### Git Rules
- Use lowercase for commit messages
- Keep the summary line concise
- Include description for non-obvious changes
- Reference issue numbers when applicable
- Use semantic versioning
- Keep commits atomic
- Use feature branches

### Development Workflow
- Use Docker for development
- Implement hot reload for development
- Use environment variables for configuration
- Maintain separate development and production configs
- Use proper logging levels
- Implement proper debugging tools
- Use type checking in development


